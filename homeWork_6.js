// 1) Почитать про принципы программирования KISS, DRY, YAGNI + почитать про "Антипаттерны" Чистого кода

/*

KISS - keep it simple stupid (необходимо придерживаться написания простого понятного кода, который смогут прочитать и понять другие программисты)

DRY - don't repeat yourself (необходимо избегать повторяющихся частей кода)

YAGNI - you are not gonna need it (необходимо писать тот функционал, который требуется для реализации задачи и неперегружать код ненужными функциями, которые могут и не понадобиться в будущем)


АНТИПАТЕРНЫ В КОДИРОВАНИИ:

1. МАГИЧЕСКИЕ ЧИСЛА/СТРОЧКИ (Magic number) - использование чисел/строковых констант без имен и пояснений.
2. СПАГЕТТИ-КОД (Spaghetti code) - сложный и запутанный кода, читаемость которого очень низкая.
3. ТАИНСТВЕННЫЙ КОД (Cryptic code) - непонятные абриавиатуры в коде.
4. ЖЕСТКОЕ КОДИРОВАНИЕ (Hard code) - сохранение в исходном коде конфигурационных данных.
5. МЯГКОЕ КОДИРОВАНИЕ (Soft code) - сохранение всех данных в конфигурационных файлах.
6. СЛЕПАЯ ВЕРА (Blind faith) - недостаточная проверка корректности входных данных.

АНТИПАТЕРНЫ В ООП:

1. КЛАСС/ОБЪЕКТ БОГА (God object) - классы/объекты с большим количеством зависимостей и ответственностей.
2. ПОЛТЕРГЕЙСТ (Poltergeist) - классы/объекты не несущие пользы, которые используются для вызова методов другого класса.
3. ОДИНОЧКА (Singletonitis) - использование слишком большого количества 'одиночек' (синголтонов).
4. КАША ИЗ ИНТЕРФЕЙСОВ (Interface soup) - объединение нескольких интерфейсов, разделенных согласно принципу разделения интерфейсов (ISP), в один.
5. ЗАГЛУШКА (Stub) - 'натягивание' на объект уже имеющегося, но малоподходящего по смыслу интерфейса.

МЕТОДОЛОГИЧЕСКИЕ ПАТТЕРНЫ:

1. ПРОГРАММИРОВАНИЕ МЕТОДОМ КОПИРОВАНИЯ И ВСТАВКИ (Copy and paste programming) - многократное копирпование существующего кода, вместо создания общих решений.
2. ЗОЛОТОЙ МОЛОТОК (Golden hammer) - уверенность в том, что любимое и хорошо освоенное решение универсально применимо.
3. ФАКТОР НЕВЕРОЯТНОСТИ (Improbability factor) - предположение о невозможности того, что сработает известная ошибка.
4. ИЗОБРЕТЕНИЕ КОЛЕСА?ВЕЛОСИПЕДА - создание с нуля, если для этого уже есть необходимые инструменты в виде методов, библиотек или API.
5. АД ЗАВИСИМОСТЕЙ - использование слишком большого количества зависимостей в виде каких-либо библиотек, которые в свою очередь зависят от других библиотек.

ДРУГИЕ АНТИПАТЕРНЫ:

1. ПРЕЖДЕВРЕМЕННАЯ ОПТИМИЗАЦИЯ - проведение оптимизации до того, как собраны какие-то данные, которые могут дать оценку существующего решения.
2. БАЙКШЕЙДИНГ (Bike-shading) - трата большого количества времени на простые решения.
3. АНАЛИТИЧЕСКИЙ ПАРАЛИЧ - чрезмерный анализ и спекуляция вместо использования пошагового развития.
4. СТРАХ ПЕРЕД ДОБАВЛЕНИЕМ КЛАССА - большое число классов не признах плохого кода.
5. ЭФФЕКТ ВНУТРЕННЕЙ ПЛАТФОРМЫ - переизобретение тех возможностей, которые уже есть на платформе.
6. ЛОДОЧНЫЙ ЯКОРЬ (Boat anchor) - оставлять НЕиспользуемый код в базе на случай возможного его использования в будущем.

*/ 



// 2) Прочитать про способы хранения LocalStorage, SessionStorage и Cookie

/*

LocalStorage - один из способов хранить данные в браузере. Это объект, хранящийся в объекте window и позволяющий долговременно сохранять данные в браузере.
Работает как хранилище данных в формате ключ-значение. При сохранении данных указывается имя поля, в которое необходимо сохранить данные, а также это имя поля 
используется для их получения. Значения хранятся в виде строк (при попытке сохранения других типов данных, они будут приведены к строке, поэтому при чтении этого свойства вернется строка).
LS не имеет ограничений по времени сохранения, может быть очищен пользователем вручную или браузером при переполнении автоматически (браузеры на основе движка WebKit, например, Safari, очищают localStorage,
если к нему не обращались в течении 7 дней). Максимальный объем данных ограничен 5МБ. 

window.localStorage.setItem('name', 'some name') // запись данных
window.localStorage.getItem('name') // чтение данных
window.localStorage.remove('name') // удаление данных
window.localStorage.clear() // очистка хранилища от всех данных
window.localStorage.length // покажет количество полей, которое записано в хранилище

Повторная запись по тому же ключу приведет к перезаписыванию данных. Если при чтении по ключу нет значения, то возвращается null.
Запись в LS является синхронной. Это значит, что на время записи браузер не выполняет другие действия.


SessionStorage - это также способ хранения данных в браузере, но в отличии от LocalStorage, данные могут храниться только в течении сессии.
Сессия страницы создается при открытии вкладки браузера. Сессия остается активной до тех пор, пока открыта вкладка браузера и это состояние сохраняется 
даже при перезагрузке страницы. Открытие новой вкладки с таким же адресом создаст новую сессию.

window.sessionStorage.setItem('name', 'some name') // запись данных
window.sessionStorage.getItem('name') // чтение данных
window.sessionStorage.remove('name') // удаление данных
window.sessionStorage.clear() // очистка хранилища от всех данных
window.sessionStorage.length // покажет количество полей, которое записано в хранилище


Cookie - способ хранить данные в браузере и передавать их на сервер. Куки передаются на сервер в виде HTTP-заголовка, что накладывает на них ограничение, 
например, максимальный размер может достигать 4096 байт или отсутствие в содержимом пробелов/запятых. Чтобы обезопасить содержимое, его можно закодировать
с помощью функции encodeURIComponent().
Все куки храняться в свойстве document.cookie, которое представляет собой строку в формате имя=значение (пары имен и значений разделяются знаком ;).
Если присвоить свойству document.cookie новое значение, то оно не заменит полностью старую строку, добавит или изменит значение по ключу.

document.cookie = 'counter=1' // запись ключа counter со значением 1
document.cookie // чтение куки
document.cookie = `counter=1;expires=${new Date(0)}` // удаление куки

При установке cookie можно указывать не только ее название и значение, но и другие необязательные параметры.
Кроме этого, есть куки, которые нельзя прочитать или записать из JS. Это может происходит в том случае, если сервер устанавливает куки с параметром HttpOnly (доступен только для установки сервером).
Такие куки будут недоступны в document.cookie. Как правило, такие куки используются для хранения чувствительной информации (токены авторизации).
Куки не являются постоянным хранилищем, срок хранения данных по умолчанию ограничен длинной сессии и для его продления может использоваться дополнительный параметр.

Необязательные параметры куки:

- path (определяет путь, по которому будет доступна кука)
- domain (определяет домен, для которого указана кука)
- max-age и expires (определяет время жизни куки либо максимальное количество секунд - max-age либо точное время - expires)
- secure (указывает, что данная кука может быть передана только при запросах по защищенному протоколу HTTPS)
- samesite (определяет может ли данная кука быть отправлена при кросс-доменном запросе)

*/ 



// 3) HTML / CSS - Базовая структура html документа, БЭМ методология

/*

HTML — язык разметки для создания структуры веб-страницы и представления контента. Благодаря разметке браузер знает в каком порядке отображать элементы, и что они значат.
CSS — язык каскадных стилей, который задаёт визуальное оформление для HTML, SVG и других языков разметки.

// Указывает браузеру какой стандарт HTML используется в этом документе (HTML5)
<!DOCTYPE html>
// тег html сообщает браузеру, где начинается контент, который нужно обработать как HTML. Этот тег содержит атрибут lang, который указывает язык на котором отображается веб-страница.
<html lang='ru'>
// тег head содержит основную информацию о документе: метаданные (кодировка, viewport, ключевые слова, краткое описание страницы), ссылки на скрипты и таблицы стилей 
<head>
	<meta charset='UTF-8'>
	<meta name='viewport' content="width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes">
	<link rel="shortcut icon" type="image/png" href="/favicon.png">
	<title>Заголовок страницы</title>
</head>
<body>
// тело самой страницы
</body>
</html>

БЭМ (Блок, Элемент, Модификатор) — компонентный подход к веб-разработке. 
В его основе лежит принцип разделения интерфейса на независимые блоки. Он позволяет легко и быстро разрабатывать интерфейсы любой сложности и повторно использовать существующий код, избегая «Copy-Paste».

Блок - функционально независимый компонент страницы, который может быть повторно использован.
Элемент - составная часть блока, которая не может использоваться в отрыве от него.
Модификатор - сущность, определяющая внешний вид, состояние или поведение блока либо элемента.

*/



// 4) Почитать про паттерны функционального программирования + посмотреть примеры использования

/*

Функциональное программирование — одна из парадигм, которые помогают спроектировать программу так, чтобы она верно отражала эти правила и была устойчивой к изменениям.
В функциональном программировании элемент композиции — это функция. Передача данных через несколько вызовов функций — их композиция.
Чтобы композиция функций была проще и не вызывала проблем, эти функции должны быть чистыми (pure).

ЧИСТАЯ ФУНКЦИЯ — это функция, которая не вызывает побочных эффектов (side effects), то есть никак не влияет на состояние внешнего мира.
Чистая функция возвращает всегда один и тот же результат при одинаковых входных данных.

РЕКУРСИЯ - это функция, которая вызывает саму себя. В рекурсии обязательно должен быть базовый случай - это условие, при выполнении которого рекурсия заканчивается.

ФУНКЦИИ ВЫСШИХ ПОРЯДКОВ - это функции, которые принимают другие функции как аргументы или возвращают функции как результат.

КАРРИРОВАНИЕ - это трансформация функций таким образом, чтобы они принимали аргументы не как f(a,b,c), а как f(a)(b)(c). Другими словами это процесс преобразования функции с несколькими аргументами
в последовательность вложенных функций, каждая из которых принимает на вход только один аргумент.

ИММУТАБЕЛЬНОСТЬ - это неизменяемое состояние. В функциональном программировании любое значение считается неизменяемым и чтобы его поменять, нужно создать копию с изменениями.

МЕМОИЗАЦИЯ - это когда функция может сохранять свои результаты для определенных входных данных и повторно их (результаты) использовать при последующих вызовах при тех же входных данных.

*/



// 5) Способы позиционирования контента на странице

/*

Свойство position в CSS задает способ позиционирования элементов в документе.
Это свойство применяется совместно с другими CSS свойствами left, right, top, bottom или inset.

Свойство position может принимать одно из нескольких значений:

- static (значение по умолчанию - элемент располагается в нормальном потоке документа согласно контексту форматирования родительского элемента')
- relative (элемент позиционируется как static, но его отображение может быть смещено при помощи свойств left, right, top, bottom или inset')
- absolute (при таком способе элемент убирается из основного потока документа, то есть перестает влиять на положение окружающих элементов и на размер родителя, при этом позиционируется относительно ближайшего позиционированного предка)
- fixed (в этом случае элемент также убирается из потока документа и его позиционирование будет не относительно родителя, а относительно окна браузера вне зависимости от вложенности)
- sticky (элемент позиционируется в нормальном потоке документа и смещается при помощи свойств top, bottom, left, right, inset относительно ближайшего родителя, имеющего прокрутку)

*/




// 6) Веса селекторов

/*
Специфичность (Вес) — это алгоритм, благодаря которому браузер определяет, какие именно стили из всего набора применить к элементу. В вычислениях участвуют CSS-селекторы. 
Если одному и тому же элементу подходит сразу несколько CSS-правил с разными селекторами, то браузер применяет те стили, вес селектора которых больше. 
Правило каскада «кто ниже, тот и выигрывает» при этом может нарушаться.

Селекторы по убыванию специфичности(веса):

1. Селекторы по идентификатору
2. Селекторы по классу, селекторы по атрибуту и селекторы с псвевдоклассами
3. Селекторы по тегу, селекторы с псевдоэлементами 

Комбинаторы +, >, ~, универсальный селектор * и псевдокласс :where() веса не имеют.

Псевдоклассы :is(), :has() и :not() принимают вес наиболее специфичного селектора внутри скобок.

Существует удобный способ вычисления веса селектора в уме. Выше мы перечислили три группы сущностей, из которых может состоять селектор. 
Представим любой селектор в виде трёх нулей: 0.0.0.

Селекторы по идентификатору увеличивают первую цифру.
Селекторы по классу, по атрибуту или псевдокласс увеличивают вторую цифру.
Селектор по тегу или псевдоэлемент увеличивают третью цифру.
Один селектор равен единице.

Например, селектор с весом 1.0.0 будет приоритетнее селектора с весом 0.1.0, в то время как 0.1.0 будет более приоритетнее селектора 0.0.2

Кроме этого, CSS-свойства, написанные в атрибуте style внутри HTML-разметки, перебивают свойства, написанные для этого элемента во внешних CSS-файлах или внутри тега <style>. 
Так что формально атрибут style самый специфичный, у него самый большой вес.

Ключевое слово !important нарушает все установленные спецификацией законы и насильно применяет свойство, после которого написано.
*/