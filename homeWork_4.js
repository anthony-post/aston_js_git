/*
1) Какие бывают алгоритмы сортировок ? 

Алгоритмы сортировки подразделяются на стабильные и нестабильные. Стабильным алгоритмом является тот, который не меняет порядок элементов с одинаковыми значениями относительно друг друга.
Нестабильный - не может гарантировать такой порядок.

- Сортировка пузырьком (в этой сортировке перебирается весь массив элементов, сравнивая два соседних элемента друг с другом и меняя их местами в соответсвии с условиями.
Элементы с большим значением опускаются вниз массива, а элементы с меньшим значением поднимаются вверх, подобно пузырькам газа). Этот алгоритм стабильный. Сложность алгоритма - O(n^2)

- Быстрая сортировка (в этом алгоритме определяется стержень и массив разбивается на подмассивы относительно этого стержня, которые затем сортируются). Этот алгоритм нестабильный. 
Сложность алгоритма в среднем O(n * log n), в худшем случае O(n^2).

- Сортировка слиянием (основной принцип этого алгоритма сортировки в том, что массив разделяется пополам, далее каждый подмассив отсортировывается слиянием, после чего оба подмассива соединяются)

- Сортировка выбором (этот алгоритм сортировки при каждой итерации проходит по неотсортированной части массива, находит минимальный элемент и переносит его в начало массива). 
Этот алгоритм может быть как стабильным, так и нестабильным. Сложность алгоритма O(n^2).

- Циклическая сортировка (данный алгоритм сортировки раскладывает массив на циклы. В каждом из циклов происходят перестановки элементов до тех пор, пока все циклы не завершатся и массив 
не будет отсортирован). Этот алгоритм нестабильный. Сложность алгоритма O(n^2).

*/



/*
2) Прочитать про "Операторы и выражения, циклы в JS"

// ОПЕРАТОРЫ

Оператор является внутренней функцией JS.

Существует 3 категории операторов по КОЛИЧЕСТВУ ОПЕРАНДОВ, с которыми они могут работать:

- Унарные (используются с одним операндом), например, i++, +str, -num
- Бинарные (используют два операнда), например, a + b, a == b, a === b
- Тернарные (используют три операнда), например, isExist ? true : false

Существует 2 категории операторов по ВНЕШНЕМУ ПРЕДСТАВЛЕНИЮ:

- Символьные, например, '+', '-', '*'
- Текстовые, например, 'instanceof'

Кроме этого операторы можно разделить на несколько категорий по ФУНКЦИИ НАЗНАЧЕНИЯ:

- Арифметические, например, '+', '/', '%'
- Логические, например, '&&', '||', '!', '??'
- Присваивания, например, '=', '+=', '-='
- Сравнения, например, '==', '!===', '>', '<='
- Группировки, например, '()'
- Отношения, например, 'in', 'instanceof'
- Битовыеб например, '&', '~', '>>', '<<<'
- Строковые, например, '+', '=='
- Создание объекта, например, 'new'
- Удаление объекта, свойства объекта, например, 'delete'


// ВЫРАЖЕНИЯ

Выражением является блок кода, который возвращает значение. Например, 5 + 3 вернёт 8, а Math.random() — случайное число.

Существует 2 типа выражений:

- с присвоением к переменной, например, a = 3
- вычисляемые без присвоения к переменной, например, a * b

Существует несколько категорий выражений:

- Логические
- Арифметические
- Строковые
- Основные
- Левосторонние


// ЦИКЛЫ

Циклом является повторяющаяся последовательность действий. В цикле есть условие и тело самого цикла. 
Условие — это выражение, которое JS вычислит в значение.
Тело цикла - блок кода. 

Перед запуском цикла проверяется условие. Если условие истинное, то выполняется тело цикла. 
Затем этот шаг повторяется. Так будет продолжаться, пока условие не станет ложным.
Каждое выполнение тела цикла называется итерацией.

Выражения в условии можно комбинировать с помощью логических операторов (например, '&&', '||').
В более сложном случае условие будет вычисляться в какой-либо другой тип: число, строку, массив, объект и т.д. В этом случае JS будет приводить получившееся значение к логическому типу.

Внутри цикла можно использовать оператор break, он прерывает цикл.
Внутри цикла можно использовать оператор continue, он прерывает текущую итерацию и возвращается к проверке условия.

Примеры циклов в JS

- for (выполняет блок кода заданное количество раз)
- while (выполняет блок кода, пока заданное условие является истинным)
- do while (выполняет блок кода минимум один раз, далее выполняется, пока заданное условие является истинным)
- for of (выполняет перебор сущностей и проходит по значениям свойств. Может применяться для перебора массива)
- for in (выполняет перебор объекта по его именам свойств (ключам). Важный момент заключается в том, что в цикле будут перечислены не только собственные свойства объекта, но и все перечисляемые свойства из прототипа объекта и прототипа прототипа и т.п.)

*/



/*
3) Создать объект Person несколькими способами, после создать объект Person2, чтобы в нём были доступны методы объекта Person. 
Добавить метод logInfo чтоб он был доступен всем объектам.
*/

// создание объекта person с помощью литерала
const person = {
	name: 'Anton',
	language: 'JS',
	city: 'Kazan',
}

// создание объекта person с помощью конструктора
const person = new Object({
	name: 'Anton',
	language: 'JS',
	city: 'Kazan',
})

// создание объекта person с помощью класса
class Person {
	constructor(name, language, city) {
		this.name = name;
		this.language = language;
		this.city = city;
	}
}

const person = new Person('Anton', 'JS', 'Kazan')


// Вариант 1 - создание объекта person2, в котором доступны методы объекта person (с помощью Object.setPrototypeOf) ???
const person2 = Object.setPrototypeOf({}, person)

// Вариант 2 - создание объекта person2, в котором доступны методы объекта person (с помощью Object.create())
const person2 = Object.create(person, {
	name: { value: 'Alex', writable: true, configurable: true, enumerable: true },
	language: { value: 'Python', writable: true, configurable: true, enumerable: true },
	city: { value: 'Moscow', writable: true, configurable: true, enumerable: true },
})

// Вариант 3 (устаревший способ) - создание объекта person2, в котором доступны методы объекта person (с помощью геттера/сеттера __proto__)
const person2 = {
	name: 'Alex',
	language: 'Python',
	city: 'Moscow',
	__proto__: person
}


// Вариант 1 - метод logInfo() добавляется объекту person и будет доступен объекту person и person2
person.logInfo = function() {
	return `${this.name} ${this.language} ${this.city}`
}

// Вариант 2 - метод logInfo добавляется через Object.defineProperty() объекту person и будет доступен объекту person и person2
Object.defineProperty(person, 'logInfo' {
	value: function() {
		return `${this.name} ${this.language} ${this.city}`
	},
	configurable: true
})

// Вариант 3 - метод logInfo() добавляется через прототип и будет доступен всем объектам
Object.prototype.logInfo = function() {
	return `${this.name} ${this.language} ${this.city}`
}



/*
4) Создать класс PersonThree c get и set для поля name и конструктором, сделать класс наследник от класса Person.
*/

// Вариант 1 (публичное поле name)
class Person {
	
	name

	constructor(name) {
		this.name = name;
	}
}

class PersonThree extends Person {
	constructor(name) {
		super(name)
	}

	get name() {
		return super.name
	}

	set name(newValue) {
		super.name = newValue
	}
}

const personMe = new PersonThree('Anton')
personMe.name // Anton


// Варинат 2 (защищенное поле _name)

class Person {

	_name

	constructor(name) {
		this._name = name
	}
}

class PersonThree extends Person {
	constructor(name) {
		super(name)
	}

	get name() {
		return this._name
	}

	set name(newValue) {
		this._name = newValue
	}
}

const anotherPerson = new PersonThree('Alex')
anotherPerson.name // Alex



/*
БОНУС: 
1) Написать функцию, которая вернет массив с первой парой чисел, сумма которых равна total
2) Какая сложность у вашего алгоритма ?
*/

const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
const total = 13;
//result = [4, 9]

// Вариант 1 (использование 2-х вложенных циклов) - сложность алгоритма O(n^2)

const firstSum = (arr, total) => {

      for(let i = 0; i < arr.length; i++) {

      	 for(let j = i + 1; j < arr.length; j++) {

      	 	if((arr.at(i) + arr.at(j)) === total) {
      	 		return [arr.at(i), arr.at(j)]
      	 	}

      	 }

      }
    // в случае если нет пары чисел возвращается пустой массив
	return []
}

firstSum(arr,total)


// Вариант 2 (использование хэш-таблицы) - сложность алгоритма O(n)

const firstSum2 = (arr, total) => {
	const hashObj = {}

	for(let i = 0; i <= arr.length; i++) {
		hashObj[i] = true
	}

	for(let i = 0; i < arr.length; i++) {		
		const diff = total - arr.at(i)

		if(diff in hashObj) {
			return [arr.at(i), diff]
		}
	}
	// в случае если нет пары чисел возвращается пустой массив
	return []
}

firstSum2(arr, total)