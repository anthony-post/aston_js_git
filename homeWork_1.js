/*
1. Подробно прочитать про метод запроса OPTIONS - и кратко его описать, когда вызывается, где используется, что передает и принимает. 

Метод представляет запрос информации об опциях соединения, 
доступных в цепочке запросов/ответов, идентифицируемой запрашиваемым URI (Request-URI). 
Этот метод позволяет клиенту определять опции и/или требования, связанные с ресурсом, 
или возможностями сервера, но не производя никаких действий над ресурсом и не инициируя его загрузку.

OPTIONS возвращает параметры в заголовке. Список параметров зависит о ресурса и/или сервера. 
Обычно это заголовок Allow, который описывает какие методы доступны для ресурса.
К примеру, если есть URL http://cats.com/cat, и его можно использовать для получения списка кошек или добавления кошки, 
то методы, которые вернет запрос OPTIONS – это GET и POST.

Кроме этого, c помощью метода OPTIONS можно отправлять предзапросы по технологии CORS. 

В этом случае в предзапросе от клиента будут присутствовать заголовки 
- Access-Control-Request-Method с указанием конкретного метода (н-р, POST).
- Access-Control-Request-Headers c указанием пользовательских заголовков (н-р, X-PINGOTHER, Content-Type).

Тогда ответ от сервера будет содержать параметр Access-Control-Allow-Methods и сообщать, что, н-р, методы POST, GET и OPTIONS
являются допустимыми для данного ресурса. Этот заголовок похож на заголовок Allow , но используется строго в контексте CORS.
А также в ответе будет параметр Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
*/


/*
2) Прочитать и описать ключевые особенности "HTTP" Версии 3.0

Целью HTTP/3 является обеспечение быстрых, надежных и безопасных веб-соединений на всех типах устройств за счет решения проблем передачи данных (транспортный протокол) в HTTP/2. 
Для этого он использует другой сетевой протокол транспортного уровня, называемый QUIC, который работает поверх интернет-протокола User Datagram Protocol (UDP) вместо TCP, используемого во всех предыдущих версиях HTTP.

Две ключевые заявленные основные цели QUIC — разрешить блокировку заголовка строки на уровне пакетов и уменьшить задержку в HTTP-соединениях и трафике. 

Количество рукопожатий сводиться к одному (вместо 2-3 в HTTP2.0), то есть в один запрос упаковано
установление соединения и установление шифрования.

При разрыве соединения не нужно устанавливать новое, то есть не будет повторных рукопожатий, 
так как используется уникальный идентификатор соединения.
*/


/*
3) Прочитать про способы отмены запроса, включая объект "AbortController"


Есть несколько способов отмены HTTP запроса со стороны клиента - с помощью JQuery(вызывается метод abort у объекта запроса), библиотеки Axios (используется параметр cancelToken) 


AbortController - это, простыми словами, интерфейс, который позволяет управлять отменой http запросов со стороны фронтенда.

AbortController - это специальный встроенный объект, который можно использовать для отмены запросов, например, через fetch
или других асинхронных задач. У объекта AbortController есть единственный метод abort() и единственное свойство signal.

let controller = new AbortController()

При вызове метода abort() генерируется событие с таким же именем 'abort' на объекте controller.signal и свойство 
controller.signal.aborted становится true.

Все, кто хочет узнать о вызове abort(), ставят обработчики на controller.signal, чтобы отслежиать его.

let controller = new AbortController()
let signal = controller.signal

signal.addEventListener('abort', () => alert('отмена'))

В случае отправкой запроса через fetch,	необходимо передать свойство signal опцией в метод fetch

let controller = new AbortController()
fetch(url, {
	signal: controller.signal
})

Чтобы прервать fetch нужно вызвать controller.abort(). В этом случае fetch получает событие из signal и прерывает запрос.

AbortController масштабируемый, он позволяет отменить несколько запросов fetch одновременно.
*/


/*
3) Написать по 2 примера создания примитивных значений (если есть несколько способов - использовать) (string, number, boolean, null, undefined, symbol, bigInt)

STRING
let emptyString = ''
const SOME_STRING = new String("Some string")
var newString = `New string with ${SOME_STRING}`

NUMBER
let someNumber = 2024
const PI = 3.14159265359
var someNegativeNumber = new Number(-123)

BOOLEAN
let isChecked = true
const compareResult = 2 > 3
var someBoolean = new Boolean(false)

NULL
let emptyValue = null
var anotherEmptyValue = null

UNDEFINED
let undefinedValue = undefined
var anotherUndefinedValue

SYMBOL
let someEmptySymbol = Symbol('')
const symbolId = "2323-erewr"
const someSymbolWithId = Symbol(symbolId)
var anotherSymbol = Symbol.for('registryrKey')

BIGINT
let someBigInt = 90989084905834n
const anotherBigInt = BigInt('32432434309323')
*/


/*
4) Почему, если обратиться к переменным созданным через let, const до их объявления - мы получаем ReferenceError? 

Временная мертвая зона — это период в JavaScript, в течение которого переменная существует, но к ней нельзя получить доступ или на нее нельзя ссылаться. 
Это происходит, когда переменная объявлена с let или const, но еще не инициализирована значением. Доступ к переменной в TDZ приводит к результату ReferenceError.
*/


/*
5) Решить: 

const res = "B" + "a" + (1 - "hello");
console.log(res); 
// ответ BaNaN (в скобках в результате арифметической операции строка 'hello' неявно приводится к NaN - Not a Number)
// как результат 1 - NaN равно NaN
// далее в результате арифметической операции происходит неявное приведение NaN к строке и происходит конкатенация трех строк

const res2 = (true && 3) + "d";
console.log(res2); 
// ответ '3d'
// логический оператор && возвращает либо первое false значение либо последнее true значение
// как результат в скобках будет число 3
// в результате арифметической операции число 3 неявно приведено к строке '3' и далее происходит конкатенация строк

const res3 = Boolean(true && 3) + "d";
console.log(res3); 
// ответ 'trued'
// в скобках в результате логического выражения с оператором && будет число 3
// конструктор Boolean c числом 3 вернет true
// в результате арифметической операции булево значение true приведется к строке 'true'
// далее произойдет конкатенация строк 'true' и 'd' 
*/